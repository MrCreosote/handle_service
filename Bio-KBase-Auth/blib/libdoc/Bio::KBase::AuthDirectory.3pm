.\" Automatically generated by Pod::Man 2.23 (Pod::Simple 3.14)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Bio::KBase::AuthDirectory 3"
.TH Bio::KBase::AuthDirectory 3 "2012-07-09" "perl v5.12.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "Bio::KBase::AuthDirectory"
.IX Header "Bio::KBase::AuthDirectory"
Administrative \s-1API\s0 for manipulating users, keys and tokens on the profile server
.SS "Examples"
.IX Subsection "Examples"
use Bio::KBase::AuthDirectory;
.PP
\&\f(CW$ad\fR = new Bio::KBase::AuthDirectory;
.PP
# Lookup user records based on user_id, consumer key and token
.PP
\&\f(CW$user\fR = \f(CW$ad\fR\->lookup_user('sychan');
.PP
\&\f(CW$user\fR = \f(CW$ad\fR\->lookup_consumer('key1');
.PP
\&\f(CW$user\fR = \f(CW$ad\fR\->lookup_oauth2_token('token1');
.PP
# Lets create a new user with minimal attributes and
.PP
# write it into the profile service
.PP
\&\f(CW$user\fR = new Bio::KBase::AuthUser;
.PP
\&\f(CW$user\fR\->user_id('sychan2');
.PP
\&\f(CW$user\fR\->name('s chan again');
.PP
\&\f(CW$user\fR\->email('sychan2@lbl.gov');
.PP
\&\f(CW$newuser\fR = \f(CW$ad\fR\->create_user( \f(CW$user\fR);
.PP
# Okay, lets delete them
.PP
\&\f(CW$ad\fR\->delete_user($newuser\->user_id);
.SS "Instance Variables"
.IX Subsection "Instance Variables"
.IP "\fBerror_message\fR" 4
.IX Item "error_message"
This is a string containing the last error generated by a call to an AuthDirectory method
.SS "Methods"
.IX Subsection "Methods"
.IP "\fBnew\fR([string registry \s-1URL\s0],[\s-1TBD\s0 admin credentials])" 4
.IX Item "new([string registry URL],[TBD admin credentials])"
returns Bio::KBase::AuthDirectory
.Sp
Optionally takes: (not yet implemented)
registry \s-1URL\s0 \- a \s-1URL\s0 to a particular user registry. Will default to the standard registry, but can be used to connect to different ones
admin credentials \- credentials for administrative access to the Registry
.Sp
Administrative credentials allow updates and access to fields such as a\*^XXconsumer secreta\*^XX and various tokens. Otherwise the registry allows lookups of users and their public information, but no ability to update the store, aside from the currently logged in user
.IP "\fBlookup_user\fR(string user_id)" 4
.IX Item "lookup_user(string user_id)"
returns Bio::KBase::AuthUser
.IP "\fBlookup_consumer\fR(string consumer_key)" 4
.IX Item "lookup_consumer(string consumer_key)"
returns Bio::KBase::AuthUser
.IP "\fBlookup_oauth2_token\fR(string token)" 4
.IX Item "lookup_oauth2_token(string token)"
returns Bio::KBase::AuthUser
.Sp
These three methods lookup user records based on user_id, consumer_key or token respectively. All return a single AuthUser object if successful, undef others.
.IP "\fBcreate_user\fR( Bio::KBase::Authuser user)" 4
.IX Item "create_user( Bio::KBase::Authuser user)"
returns Bio::KBase::AuthUser
.Sp
When given a populated user object, will create a new user in the registry and return it. If there is an error will return null and set error_msg. Must have administrative privs to create new users
.IP "\fBdelete_user\fR( string user_id)" 4
.IX Item "delete_user( string user_id)"
returns boolean
.Sp
When given a user_id, will delete that user from the database
.IP "\fBenable_user\fR( string user_id)" 4
.IX Item "enable_user( string user_id)"
returns boolean
.Sp
Enables a user based on the user_id. This user will once again be able to login. Can only be used with admin privs
.IP "\fBdisable_user\fR( string user_id)" 4
.IX Item "disable_user( string user_id)"
returns boolean
.Sp
Disables a user based on user_id. This user will be unable to login. Can only be used with admin privs
.IP "\fBnew_consumer\fR( string user_id,[oauth_key, oauth_secret])" 4
.IX Item "new_consumer( string user_id,[oauth_key, oauth_secret])"
returns hash {oauth_key => key, oauth_secret => secret}
.Sp
Creates a consumer (key,secret) pair and associates it with that user in the directory. Alternatively, if a (key,secret) is passed in, this new pair will be associated with the usera\*^XXs profile. This pair can then be used to authenticate to the system. The key is guaranteed to be unique within the directory. The secret is not guaranteed to be unique, but it should an otherwise random value. There is some leeway in the consumer key \- it can be a user readable, but unique string (for example username + sequence number) or just an opaque string such as a hash. The secret should be the base64 encoding of reasonably sound entropy source (256 bits from a well designed entropy source). It is important that the secret not pass over a cleartext channel.
.IP "\fBdelete_consumer\fR( string consumer_key)" 4
.IX Item "delete_consumer( string consumer_key)"
returns boolean
.Sp
Find the user record associated with the consumer_key and delete the consumer (key,secret) pair from their record. This pair can no longer be used to authenticate to the system.
