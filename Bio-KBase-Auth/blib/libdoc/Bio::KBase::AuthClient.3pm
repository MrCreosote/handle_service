.\" Automatically generated by Pod::Man 2.23 (Pod::Simple 3.14)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Bio::KBase::AuthClient 3"
.TH Bio::KBase::AuthClient 3 "2012-07-09" "perl v5.12.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "Bio::KBase::AuthClient"
.IX Header "Bio::KBase::AuthClient"
.Vb 1
\&   Client libraries that handle KBase authentication.
.Ve
.SS "Examples:"
.IX Subsection "Examples:"
.IP "Conventional OAuth usage with Authorization header in http header:" 4
.IX Item "Conventional OAuth usage with Authorization header in http header:"
.Vb 2
\&    my $ua = LWP::UserAgent\->new();
\&    my $req = HTTP::Request\->new( GET => $server. "someurl" );
\&
\&    # Create a KBase client and attach the authorization headers to the
\&    # request object. Use a "key" and "secret" as the secret
\&    my $ac = Bio::KBase::AuthClient\->new(consumer_key => \*(Aqkey\*(Aq, consumer_secret => \*(Aqsecret\*(Aq);
\&    unless ($ac\->{logged_in}) {
\&        die "Client: Failed to login with credentials!";
\&    }
\&    unless ($ac\->sign_request( $req)) {
\&        die "Client: Failed to sign request";
\&    }
\&    my $res = $ua\->request( $req);
\&    print $res\->content
.Ve
.IP "Embedding a non-standard OAuth token within JSON-RPC message body:" 4
.IX Item "Embedding a non-standard OAuth token within JSON-RPC message body:"
.Vb 3
\&    # The arguments to the method call
\&    #
\&    my @args = ("arg1", "arg2");
\&
\&    my $wrapped_params = {
\&        args => \e@args,
\&    };
\&
\&    #
\&    # The JSONRPC protocol data.
\&    #
\&    my $jsonrpc_params = {
\&        method => "module.server_call",
\&        params => [$wrapped_params],
\&    };
\&
\&    # Use the oauth libraries to create an oauth token using "jsonrpc" as
\&    # the method, and a digest hash of rpc call parameters as the \*(Aqurl\*(Aq
\&    # this construction isn\*(Aqt recognized anywhere outside of KBase
\&    # On the server side, to validate the request, you would extract
\&    # all the components and compute the md5_base64 hash of the
\&    # contents of $json_call, and then make a call like this
\&    # $as = Bio::KBase::AuthServer
\&    # $inf{request_method} = "jsonrpc";
\&    # $inf{request_url} = $param_hash
\&    # if ( $as\->validate_auth_header( $token, %inf)) {
\&    #         good stuff
\&    # } else {
\&    #         bad stuff
\&    # }
\&    my $json_call = to_json( $jsonrpc_params);
\&    my $param_hash = md5_base64( $json_call);
\&
\&    my $token = $ac\->auth_token( request_method => \*(Aqjsonrpc\*(Aq,
\&                                 request_url => $param_hash );
\&    my $wrapped = { params => [$json_call, $token],
\&                    version => 1.1,
\&                    method => "module.method_name" };
\&
\&    $req\->content( to_json( $wrapped));
\&
\&    # Sign the http request for oauth
\&    unless ($ac\->sign_request( $req)) {
\&        die "Client: Failed to sign request";
\&    }
\&     my $res = $ua\->request( $req);
\&    printf "Client: Recieved a response: %s\en", $res\->content;
.Ve
.SS "Environment"
.IX Subsection "Environment"
.Vb 2
\&   User home directories can contain $auth_rc, which is a JSON formatted file with declarations for authentication information (similar to a ~/.netrc file)
\&   It should be in the following format:
.Ve
.PP
{ \*(L"oauth_key\*(R":\*(L"consumer_key_blahblah\*(R",
  \*(L"oauth_token\*(R":\*(L"token_blah_blah\*(R",
  \*(L"oauth_secret\*(R":\*(L"consumer_secret_blahblah\*(R"
 }
.SS "Instance Variables"
.IX Subsection "Instance Variables"
.IP "\fBuser\fR (Bio::KBase::AuthUser)" 4
.IX Item "user (Bio::KBase::AuthUser)"
Contains information about the user using the client. Also the full set of oauth credentials available for this user
.IP "\fBoauth_cred\fR (hash)" 4
.IX Item "oauth_cred (hash)"
Contains the hashref to specific oauth credential used for authentication. It is a hash of the same structure as the oauth_creds entries in the Bio::KBase::AuthUser
.IP "\fBlogged_in\fR (boolean)" 4
.IX Item "logged_in (boolean)"
Did \fIlogin()\fR successfully return? If this is true then the entry in the user attribute is good.
.IP "\fBerror_message\fR (string)" 4
.IX Item "error_message (string)"
Most recent error msg from call to instance method.
.SS "Methods"
.IX Subsection "Methods"
.IP "\fBnew\fR([consumer_key=>key, consumer_secret=>secret])" 4
.IX Item "new([consumer_key=>key, consumer_secret=>secret])"
returns Bio::KBase::AuthClient
.Sp
Class constructor. Create and return a new client authentication object. Optionally takes arguments that are used for a call to the \fIlogin()\fR method. By default will check ~/.kbase\-auth file for declarations for the consumer_key and consumer_secret, and if found, will pull those in and perform a \fIlogin()\fR. Environment variables are also an option and should be discussed.
.IP "\fBlogin\fR( [consumer_key=>key, consumer_secret=>secret] | [user_id=>a\*^XXsomeuserida\*^XX,[password=>a\*^XXsomepassworda\*^XX] | [conversation_callback => ptr_conversation_function] | [return_url = async_return_url])>" 4
.IX Item "login( [consumer_key=>key, consumer_secret=>secret] | [user_id=>a^XXsomeuserida^XX,[password=>a^XXsomepassworda^XX] | [conversation_callback => ptr_conversation_function] | [return_url = async_return_url])>"
returns boolean for login success/fail.
.Sp
If no parameters are given then consumer (key,secret) will be populated automatically from ~/.kbase\-auth. Environment variables are also an option.
.Sp
When this is called, the client will attempt to connect to the back end server to validate the credentials provided.
The most common use case will be to pull the consumer_key and consumer_secret from the environment. You can also specify the user_id and password for authentication \- this is only recommended for bootstrapping the use of consumer (key,secret).
.Sp
If the authentication is a little more complicated there are 2 options
  \- define a function that handles the login interaction (same idea as the \s-1PAM\s0 conversation function).
  \- if wea\*^XXre in a web app that needs oauth authentication, then the client browser will need to be redirected back and forth. A return url where control will pass once authentication has completed needs to be provided ( see this diagram for an example). If the return_url is provided, this function will not return.
.IP "\fBsign_request\fR( HTTPRequest request_object,[Bio::KBase::AuthUser user])" 4
.IX Item "sign_request( HTTPRequest request_object,[Bio::KBase::AuthUser user])"
returns boolean
.Sp
Called to sign a http request object before submitting it. Will push authentication/authorization messages into the \s-1HTTP\s0 request headers for authentication on the server side. With OAuth 1.0(a) this will be one set of headers, and with OAuth 2.0 it should be a smaller, simpler set of headers
   This method must be called on a request object to a\*^XXsigna\*^XX the request header so that the server side can authenticate the request.
   Note that different authentication methods have different requirements for a request:
   1) username/password requires \s-1SSL/TLS\s0 for obvious reasons
   2) oauth1 uses shared secrets and cryptographic hashes, so the request can be passed in the clear
   3) oauth2 using \s-1MAC\s0 tokens use a shared secret, so the request can be in cleartext
   4) oauth2 using Bearer tokens uses a text string as a combination username/password, so it must be over \s-1SSL/TLS\s0
   If the transport protocol violates the requirements of the authentication method, \fIsign_request()\fR will return false and not encode any information in the request header.
   We can simplify things if we simply settle on options 2 and 3, and rule out options 1 and 4. It is also possible to finesse #1 into a cleartext protocol as well. But #4 (oauth2 bearer tokens) *must* be \s-1SSL/TLS\s0. My recommendation is to disallow #4 so that we do not have to require \s-1SSL/TLS\s0.
.IP "\fBauth_token\fR( string \s-1URL\s0,[Bio::KBase::AuthUser user]) **not yet implemented** (user consumer key/secret for now)" 4
.IX Item "auth_token( string URL,[Bio::KBase::AuthUser user]) **not yet implemented** (user consumer key/secret for now)"
returns string
.Sp
Returns a base64 encoded authentication token (tentatively based on the XOauth \s-1SASL\s0 token) that can be used for a single session within a non-HTTP protocol. The \s-1URL\s0 passed in is used to identify the resource being accessed, and is used in the computation of the hash signature. The url passed to \fIBio::KBase::AuthServer::validate_auth_token()\fR on the other end of the exchange must be identical. Authentication tokens are also timestamped and intended for a single use. The token is generated from the consumer key and secret, and should not be stored across sessions for re-use (at the very least, it should timeout even if token replay safeguards fail).
.IP "\fB\f(BInew_consumer()\fB\fR returns hash { consumer_key => key, consumer_secret => secret}" 4
.IX Item "new_consumer() returns hash { consumer_key => key, consumer_secret => secret}"
This function requests a consumer (key,secret) pair from the user directory that can be used for subsequent authentication. The (key,secret) should be stored in the environment. Note that the key/secret are associated with the account when you generate it \- please do not overuse and cause a proliferation of key/secret pairs.
.IP "\fBlogout\fR([return_url = async_return_url])" 4
.IX Item "logout([return_url = async_return_url])"
returns boolean
.Sp
Wipe out the auth info, and perform related logout functions. If we are being called in a web app, provide an asynchronous call back \s-1URL\s0 that the client browser will be redirected to after logout is called \- execution will not return if return_url is defined.
